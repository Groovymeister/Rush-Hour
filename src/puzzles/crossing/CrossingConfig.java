package puzzles.crossing;

import puzzles.common.solver.Configuration;

import java.util.Collection;
import java.util.HashSet;

/**
 * Configuration class used to solve the Crossing puzzle.
 *
 * @author John West (jrw2936@rit.edu)
 */
public class CrossingConfig implements Configuration {
    private final int leftPups;
    private final int rightPups;
    private final int leftWolves;
    private final int rightWolves;
    private final String boat;

    /**
     * Constructor for Crossing configurations.
     */
    public CrossingConfig(int leftPups, int leftWolves, int rightPups, int rightWolves, String boat) {
        this.leftPups = leftPups;
        this.leftWolves = leftWolves;
        this.rightPups = rightPups;
        this.rightWolves = rightWolves;
        this.boat = boat;
    }

    /**
     * Returns the current position of the pups and wolves on each side, and the location of the boat, as a string.
     *
     * @return String containing above information relevant to Crossing puzzle.
     */
    @Override
    public String toString() {
        if (boat.equals("left")){
            return ("(BOAT)" +
                    " left [" + leftPups + ", " + leftWolves + "] right [" + rightPups + ", " + rightWolves + "]");
        }
        else {
            return ("       left [" + leftPups + ", " + leftWolves + "] right [" + rightPups + ", " + rightWolves + "]" +
                    " (BOAT)");
        }
    }

    /**
     * Returns the string hashcode of the configuration, generated by multiplying each value by large numbers and adding
     * them.
     *
     * @return The string hashcode of the configuration.
     */
    @Override
    public int hashCode() {
        return leftWolves * 783 + rightWolves * 513 + leftPups * 345 + rightPups * 192 + boat.hashCode();
    }

    /**
     * Returns boolean containing whether the solution is achieved.
     *
     * @return Whether the start value of the configuration is the ending value.
     */

    public boolean isSolution() {
        return leftPups == 0 && leftWolves == 0 && boat.equals("right");
    }

    /**
     * Determines whether two CrossingConfigs are the same
     *
     * @param other The other CrossingConfig
     * @return Whether the configs are the same
     */

    public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof CrossingConfig otherConfig) {
            result = this.leftPups == otherConfig.leftPups && this.leftWolves == otherConfig.leftWolves
                    && this.rightPups == otherConfig.rightPups && this.rightWolves == otherConfig.rightWolves
                    && this.boat.equals(otherConfig.boat);
        }
        return result;
    }

    /**
     * Returns a Hashset of valid successors for the given starting value of the configuration.
     *
     * @return A HashSet of successor configurations.
     */

    public Collection<Configuration> getNeighbors() {
        HashSet<Configuration> neighbors = new HashSet<>();

        /* Special cases for when the boat is on the left and there's enough for one trip left */
        if (leftWolves == 0 && leftPups == 2 && boat.equals("left")) {
            neighbors.add(new CrossingConfig(0, leftWolves, rightPups + 2, rightWolves, "right"));
        }
        if (leftWolves == 0 && leftPups == 1 && boat.equals("left")) {
            neighbors.add(new CrossingConfig(0, leftWolves, rightPups + 1, rightWolves, "right"));
        }
        if (leftWolves == 1 && leftPups == 0 && boat.equals("left")){
            neighbors.add(new CrossingConfig(leftPups, 0, rightPups, rightWolves + 1, "right"));
        }

        /* Handles pups on the left */
        if (leftPups >= 2 && boat.equals("left")){
            neighbors.add(new CrossingConfig(leftPups - 2, leftWolves, rightPups + 2, rightWolves,
                    "right"));
        }
        if (rightPups >= 1 && boat.equals("right")){
            neighbors.add(new CrossingConfig(leftPups + 1, leftWolves, rightPups - 1, rightWolves,
                    "left"));
        }

        /* Handles wolves on the left */
        if (leftWolves >= 1 && rightPups >=1 && boat.equals("right")){
            neighbors.add(new CrossingConfig(leftPups + 1, leftWolves, rightPups -1, rightWolves,
                    "left"));
        }
        if (leftWolves >= 1 && rightPups >=1 && boat.equals("left")){
            neighbors.add(new CrossingConfig(leftPups, leftWolves - 1, rightPups, rightWolves+ 1,
                    "right"));
        }

        return neighbors;
    }
}
